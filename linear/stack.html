<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>스택</title>
    <link rel="stylesheet" href="../assets/css/style.css">

    <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body data-page-id="stack">

<header class="header">
    <div class="header-inner">
        <div class="breadcrumb"></div>
        <h1 class="page-title">스택</h1>
    </div>
</header>

<main class="content">

    <!-- 목차 -->
    <section class="toc">
        <h2>목차</h2>
        <ul>
            <li>
                <a href="#definition">
                    1. 스택 <span class="toc-subtitle">Stack</span>
                </a>
            </li>
            <li><a href="#implementation">2. 스택 구현 방식</a></li>
            <li><a href="#pros-cons">3. 스택의 장단점</a></li>
            <li><a href="#code">4. 예시 구현 코드</a></li>
            <li><a href="#experience">5. 체험존</a></li>
        </ul>
    </section>

    <!-- 1. 스택 정의 + 특징 -->
    <section id="definition">
        <h2 class="section-title">
            스택<span class="section-subtitle">Stack</span>
        </h2>

        <p>
            스택(Stack)은 데이터의 삽입과 삭제가
            <strong>한쪽 방향에서만</strong> 이루어지는 선형 자료구조입니다.
        </p>

        <p>
            가장 마지막에 들어온 데이터가 가장 먼저 나가는
            <strong>LIFO (Last In, First Out)</strong> 구조를 가집니다.
        </p>

        <!-- 스택 이미지 3개 -->
        <div class="stack-image-row">
            <img src="../assets/images/stack-push.png" alt="Stack push">
            <img src="../assets/images/stack-top.png" alt="Stack 상태">
            <img src="../assets/images/stack-pop.png" alt="Stack pop">
        </div>


        <ul>
            <li>접근 가능한 위치는 항상 <strong>top</strong> 하나뿐</li>
            <li>중간 요소에 직접 접근 불가</li>
            <li>연산 규칙이 단순하고 명확함</li>
        </ul>
    </section>

    <!-- 4. 구현 방식 -->
    <section id="implementation">
        <h2>스택 구현 방식</h2>

        <p>스택은 다음과 같은 방식으로 구현할 수 있습니다.</p>

        <ul>
            <li>배열(Array)을 이용한 스택</li>
            <li>연결 리스트(Linked List)를 이용한 스택</li>
        </ul>

        <h3><br>배열을 이용한 스택</h3>

        <img src="../assets/images/stack-array.png"
            alt="배열 스택"
            class="structure-img">

        <ul>
            <li>가장 마지막에 추가한 값이 <strong>top</strong></li>
            <li>배열 길이를 초과할 시 <strong>overflow</strong> 발생 가능</li>
            <li>추가/삭제의 시간 복잡도가 <strong>O(1)</strong></li>
        </ul>

        <h3><br>연결 리스트를 이용한 스택</h3>

        <img src="../assets/images/stack-list.png"
            alt="연결 리스트 스택"
            class="structure-img">

        <ul>
            <li>top 노드가 가르키는 값이 <strong>top</strong></li>
            <li><strong>overflow</strong> 발생 없이 값 추가 가능</li>
            <li>값을 빼고 넣는 것이 아닌 포인터가 가르키는 값을 변경하여 추가/삭제</li>
            <li>위 그림 처럼 연결 리스트의 head가 top일 경우, 추가/삭제의 시간 복잡도가 <strong>O(1)</strong></li>
        </ul>
    </section>

    <!-- 스택 장단점 -->
    <section id="pros-cons">
        <h2>스택의 장단점</h2>

        <div class="two-column">
            <div>
                <h3>장점</h3>
                <ul>
                    <li>구조가 단순하여 구현과 이해가 쉬움</li>
                    <li>LIFO 구조로 undo/redo, 재귀 호출 등 활용에 적합</li>
                    <li>추가/삭제의 시간 복잡도가 O(1)</li>
                </ul>
            </div>

            <div>
                <h3>단점</h3>
                <ul>
                    <li>중간 데이터를 직접 접근할 수 없음</li>
                    <li>고정 크기 스택의 경우 overflow 발생 가능</li>
                    <li>비어 있는 상태에서 pop 시 오류 발생</li>
                </ul>
            </div>
        </div>
    </section>

    <section id="code">
        <h2>예시 구현 코드 (Python)</h2>

        <p>배열을 이용한 스택의 구현 예시입니다.</p>

        <pre><code class="language-python">
class Stack:
    def __init__(self):
        self.data = []

    def push(self, value):
        self.data.append(value)

    def pop(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.data.pop()

    def peek(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        return self.data[-1]

    def is_empty(self):
        return len(self.data) == 0
        </code></pre>

        <!-- push -->
        <h3><br>push</h3>
        <pre><code class="language-python">
def push(self, value):
    self.data.append(value)    # 배열 맨 끝에 값을 추가
        </code></pre>
        <p>
            push는 최상단(top)에 <strong>데이터를 추가</strong>하는 연산입니다.<br>
            배열의 맨 끝에 값을 넣는 것이므로 시간 복잡도는 <strong>O(1)</strong>입니다.<br>
            스택은 LIFO에 따라 top에만 값을 추가할 수 있으므로 삽입은 불가능합니다.
        </p>

        <!-- pop -->
        <h3><br>pop</h3>
        <pre><code class="language-python">
def pop(self):
    if self.is_empty():                       # 스택이 비어있는지 확인
        raise IndexError("Stack is empty")    # 비어있으면 에러
    return self.data.pop()                    # top의 값을 삭제 및 반환
        </code></pre>
        <p>
            pop은 최상단(top)의 <strong>데이터를 제거하고 반환</strong>하는 연산입니다.<br>
            배열 끝의 값을 삭제하기 때문에 나머지 값을 옮길 필요가 없어 시간 복잡도는 <strong>O(1)</strong>입니다.
        </p>

        <!-- peek -->
        <h3><br>peek</h3>
        <pre><code class="language-python">
def peek(self):
    if self.is_empty():                       # 스택이 비어있는지 확인
        raise IndexError("Stack is empty")    # 비어있으면 에러
    return self.data[-1]                      # top의 값 반환
        </code></pre>
        <p>
            peek은 데이터를 제거하지 않고 <strong>최상단 값(top)</strong>을 확인하는 연산입니다.<br>
            top의 위치는 이미 알고 있으므로 시간 복잡도는 <strong>O(1)</strong>입니다.
        </p>

        <!-- is_empty -->
        <h3><br>is_empty</h3>
        <pre><code class="language-python">
def is_empty(self):
        return len(self.data) == 0    # 스택의 길이 반환
        </code></pre>
        <p>
            is_empty는 스택이 현재 <strong>비어 있는지</strong>를 확인하는 연산입니다.<br>
            스택이 비어있을 때 연산을 진행해 에러가 나는 것을 방지하기 위해 사용합니다.<br>
            반환 값은 <strong>bool(True/False)</strong> 값이며, 파이썬의 len()은 저장된 length 값을 읽어 오기 때문에 시간 복잡도는 <strong>O(1)</strong>입니다. 
        </p>

    </section>

    <!-- 체험존 -->
    <section id="experience">
        <h2 class="section-title">체험존</h2>

        <p style="color:#6b7280; font-size:0.9rem; margin-bottom:30px;">
            길이가 8인 스택
        </p>

        <div class="two-column">

            <!-- 스택 시각화 영역 -->
            <div style="display:flex; justify-content:center; gap:16px; align-items:flex-end;">

                <!-- top 표시 (JS가 위치를 조절함) -->
                <div id="topLabel"
                    style="font-weight:600; height:48px; display:flex; align-items:center;">
                    top
                </div>

                <div class="array-container" id="stackView"
                    style="flex-direction:column-reverse;">
                    <!-- JS로 채워짐 -->
                </div>
            </div>


            <!-- 컨트롤 영역 -->
            <div style="text-align:center;">
                <div style="text-align:center; margin-top:85px;"></div>

                <input id="inputValue" type="text" placeholder="값 입력">

                <div class="buttons">
                    <button onclick="push()">push</button>
                    <button onclick="peek()">peek</button>
                </div>

                <div class="buttons">
                    <button onclick="pop()">pop</button>
                    <button onclick="isEmpty()">is_empty</button>
                </div>

                <!-- 뒤로가기 버튼 -->
                <div class="buttons" style="margin-top:10px;">
                    <button onclick="undo()">뒤로가기</button>
                </div>

                <div id="result">결과 출력</div>
            </div>


        </div>
    </section>

</main>

<script src="../assets/js/siteTree.js"></script>
<script src="../assets/js/breadcrumb.js"></script>

<script>
    const pageId = document.body.dataset.pageId;
    renderBreadcrumb(pageId);
</script>

<script type="module" src="../assets/js/stackExperience.js"></script>

</body>
</html>
