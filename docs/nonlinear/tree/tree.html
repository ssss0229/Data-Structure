<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <title>트리</title>

    <!-- 공통 스타일 -->
    <link rel="stylesheet" href="../../assets/css/style.css">

    <!-- 코드 하이라이트 -->
    <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body data-page-id="tree">

<header class="header">
    <div class="header-inner">
        <div class="breadcrumb"></div>
        <h1 class="page-title">트리</h1>
    </div>
</header>

<main class="content">

    <!--목차-->
    <section class="toc">
        <h2>목차</h2>
        <ul>
            <li>
                <a href="#definition">
                    1. 트리 <span class="toc-subtitle">Tree</span>
                </a>
            </li>
            <li><a href="#terms">2. 트리 기본 용어</a></li>
            <li><a href="#traversal">3. 트리 순회법</a></li>
            <li><a href="#code">4. 트리 구현 및 연산</a></li>
            <li><a href="#search">5. 트리 탐색</a></li>
            <li><a href="#types">6. 트리의 종류</a></li>
        </ul>
    </section>

    <!--정의-->
    <section id="definition">
        <h2 class="section-title">
            트리<span class="section-subtitle">Tree</span>
        </h2>

        <p>
            트리는 <strong>그래프의 특수한 형태</strong>로,
            사이클이 존재하지 않으며 모든 노드가 하나의 연결 요소로 이루어진
            <strong>비선형 자료구조</strong>입니다.
        </p>

        <ul>
            <li>사이클이 없음</li>
            <li>모든 노드가 연결됨</li>
            <li>두 노드 사이의 경로가 항상 하나만 존재</li>
        </ul>
    </section>

    <!--용어-->
    <section id="terms">
        <h2>트리 기본 용어</h2>

        <img src="../../assets/images/treeElements.png"
             alt="트리 기본 구조"
             class="structure-img">

        <ul>
            <li><strong>노드</strong> : 데이터를 저장하는 단위</li>
            <li><strong>간선</strong> : 노드를 연결하는 선</li>
            <li><strong>부모</strong> : 노드 A에서 노드 B로 가는 간선이 있을 때 A는 B의 부모</li>
            <li><strong>자식</strong> : 노드 A에서 노드 B로 가는 간선이 있을 때 B는 A의 자식</li>
            <li><strong>형제</strong> : 같은 부모를 갖는 노드들</li>
            <li><strong>루트</strong> : 부모가 없는 노드</li>
            <li><strong>리프</strong> : 자식이 없는 노드</li>
            <li><strong>차수</strong> : 자식의 개수</li>
            <li><strong>깊이 / 레벨</strong> : 루트부터의 거리 최단 길이</li>
            <li><strong>높이</strong> : 깊이의 최댓값</li>
            <li><strong>너비</strong> : 각 레벨에 속한 정점의 수의 최댓값</li>
        </ul>
    </section>

    <!--순회-->
    <section id="traversal">
        <h2>트리 순회</h2>

        <ul>
            <li><strong>전위 순회</strong> : 루트 → 왼쪽 → 오른쪽</li>
            <li><strong>중위 순회</strong> : 왼쪽 → 루트 → 오른쪽</li>
            <li><strong>후위 순회</strong> : 왼쪽 → 오른쪽 → 루트</li>
            <li><strong>레벨 순회</strong> : 위 → 아래, 왼쪽 → 오른쪽</li>
        </ul>

        <img src="../../assets/images/tree-traversal.png"
             alt="트리 순회 방식"
             class="structure-img">
    </section>

    <!--구현-->
    <section id="code">
        <h2>트리 예시 구현 코드 (Python)</h2>

        <pre><code class="language-python">
class TreeNode:
    def __init__(self, value):
        self.value = value
        self.children = []


class Tree:
    def __init__(self, root_value):
        self.root = TreeNode(root_value)

    # 노드 삽입
    def insert(self, parent_value, new_value):
        parent = self._find(self.root, parent_value)
        if parent:
            parent.children.append(TreeNode(new_value))

    # 노드 삭제
    def delete(self, value):
        self._delete(self.root, value)

    def _delete(self, node, value):
        for child in node.children:
            if child.value == value:
                node.children.remove(child)
                return
            self._delete(child, value)
        </code></pre>

        <h3><br>삽입</h3>
        <pre><code class="language-python">
def insert(root, value):
    if root is None:
        return Node(value)

    if value < root.value:
        root.left = insert(root.left, value)
    else:
        root.right = insert(root.right, value)

    return root
        </code></pre>

        <p>
            평균 시간 복잡도는 <strong>O(log n)</strong>,
            최악의 경우 <strong>O(n)</strong>입니다.
        </p>


        <h3><br>삭제</h3>
        <pre><code class="language-python">
def delete(self, value):
    self._delete(self.root, value)   # 루트 삭제는 허용하지 않음 (단순화)

def _delete(self, node, value):
    for child in node.children:
        if child.value == value:
            node.children.remove(child)
            return
        self._delete(child, value)
        </code></pre>

        <p>
            평균 시간 복잡도는 <strong>O(log n)</strong>,
            최악의 경우 <strong>O(n)</strong>입니다.
        </p>

    </section>

    <!-- 탐색 -->
    <section id="search">
        <h2>트리 탐색</h2>

        <p>
            트리 탐색은 특정 노드를 찾거나 모든 노드를 방문하기 위해 수행됩니다.
            일반 트리에서는 정렬 규칙이 없기 때문에, 탐색 시 모든 노드를 확인해야 합니다.
        </p>

        <h3>DFS (Depth-First Search)</h3>
        <p>
            DFS는 <strong>깊이를 우선</strong>으로 탐색하는 방식으로,
            한 노드의 자식들을 끝까지 탐색한 후 다음 노드로 이동합니다.
        </p>

        <pre><code class="language-python">
    def dfs(node, target):
        if node.value == target:
            return node

        for child in node.children:
            result = dfs(child, target)
            if result:
                return result

        return None
        </code></pre>

        <ul>
            <li>재귀를 이용해 구현하기 쉬움</li>
            <li>메모리 사용량이 비교적 적음</li>
            <li>시간 복잡도: <strong>O(n)</strong></li>
        </ul>

        <h3>BFS (Breadth-First Search)</h3>
        <p>
            BFS는 <strong>너비 우선</strong> 탐색 방식으로,
            루트 노드부터 같은 깊이의 노드들을 차례대로 탐색합니다.
        </p>

        <pre><code class="language-python">
    from collections import deque

    def bfs(root, target):
        queue = deque([root])

        while queue:
            node = queue.popleft()
            if node.value == target:
                return node

            for child in node.children:
                queue.append(child)

        return None
        </code></pre>

        <ul>
            <li>큐(Queue)를 사용하여 구현</li>
            <li>가까운 깊이에 있는 노드를 먼저 찾을 때 유리</li>
            <li>시간 복잡도: <strong>O(n)</strong></li>
        </ul>
    </section>


    <!--종류-->
    <section id="types">
        <h2>트리의 종류</h2>

        <div class="grid">

            <a href="binary-tree.html" class="card">
                <div class="image-box">Binary Tree</div>
                <strong>이진 트리</strong>
            </a>

            <a href="trie.html" class="card">
                <div class="image-box">
                    <img src="../../assets/images/trie.png" alt="트라이">
                </div>
                <strong>트라이</strong>
            </a>

            <a href="heap.html" class="card">
                <div class="image-box">Heap</div>
                <strong>힙</strong>
            </a>

        </div>
    </section>

</main>

<!-- breadcrumb -->
<script src="../../assets/js/siteTree.js"></script>
<script src="../../assets/js/breadcrumb.js"></script>
<script>
    const pageId = "tree";
    renderBreadcrumb(pageId);
</script>

</body>
</html>
